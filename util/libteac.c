#include <stdio.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <string.h>

#ifdef CHROMIUM
#include <cr_string.h>
#include <cr_mem.h>
#else
#define crAlloc(sz) malloc(sz)
#define crStrncpy(out,in,sz) strncpy(out,in,sz)
#define crStrchr(instr,inchr) strchr(instr,inchr)
#endif

#include "teac.h"
#include "time.h"

/* Notes-
 * -Am I really using all the parts of Tcomm struct?
 * -Am I really using all the consts in teac.h?
 * -Should some of the constants move to libteac.c from teac.h?
 * -I really need a better user key in the capability.
 * -Do I need an event to act as a spin lock after initialization?
 * -Why is elan3_fini dropping core?
 */

#define RAIL 0

#ifdef never
static char junkString[256];
#endif

#ifdef never
static host_t hosts[] = { 
  { "mini-t0", 0, 0 }, { "mini-t1", 0, 1 },
  { "mini-t2", 0, 2 }, { "mini-t3", 0, 3 }, 
  { "dummy4", 0, 4 }, { "dummy5", 0, 5 }, { "dummy6", 0, 6 },
  { "dummy7", 0, 7 }, { "dummy8", 0, 8 }, { "dummy9", 0, 9 },
  { "dummy10", 0, 10 }, { "dummy11", 0, 11 }, { "dummy12", 0, 12 },
  { "dummy13", 0, 13 }, { "dummy14", 0, 14 }, { "dummy15", 0, 15 },
  { "vis0", 0, 16 }, { "vis1", 0, 17 }, { "vis2", 0, 18 },
};

static sdramaddr_t sdramAddrBase[]= { /* indexed by node number */
  0x14d00, /* mini-t0 */
  0x14d00, /* mini-t1 */
  0x14d00, /* mini-t2 */
  0x14d00, /* mini-t3 */
  0x00000, /* dummy4 */
  0x00000, /* dummy5 */
  0x00000, /* dummy6 */
  0x00000, /* dummy7 */
  0x00000, /* dummy8 */
  0x00000, /* dummy9 */

  0x00000, /* dummy10 */
  0x00000, /* dummy11 */
  0x00000, /* dummy12 */
  0x00000, /* dummy13 */
  0x00000, /* dummy14 */
  0x00000, /* dummy15 */
  0x13d00, /* vis0 */
  0x13d00, /* vis1 */
  0x13d00, /* vis2 */
};

static E3_Addr elanAddrBase[]= { /* indexed by node number */
  0x405400, /* mini-t0 */
  0x405400, /* mini-t1 */
  0x405400, /* mini-t2 */
  0x405400, /* mini-t3 */
  0x000000, /* dummy4 */
  0x000000, /* dummy5 */
  0x000000, /* dummy6 */
  0x000000, /* dummy7 */
  0x000000, /* dummy8 */
  0x000000, /* dummy9 */
  0x000000, /* dummy10 */
  0x000000, /* dummy11 */
  0x000000, /* dummy12 */
  0x000000, /* dummy13 */
  0x000000, /* dummy14 */
  0x000000, /* dummy15 */
  0x403400, /* vis0 */
  0x403400, /* vis1 */
  0x403400, /* vis2 */
};

#endif

#ifdef never
static host_t hosts[] = { 
  { "tcsini0", 0, 0 },
  { "tcsini1", 0, 1 }, { "tcsini2", 0, 2 }, { "tcsini3", 0, 3 },
  { "tcsini4", 0, 4 }, { "tcsini5", 0, 5 }, { "tcsini6", 0, 6 },
  { "tcsini7", 0, 7 }, { "tcsini8", 0, 8 }, { "tcsini9", 0, 9 },
  { "tcsini10", 0, 10 }, { "tcsini11", 0, 11 }, { "tcsini12", 0, 12 },
  { "tcsini13", 0, 13 }, { "tcsini14", 0, 14 }, { "tcsini15", 0, 15 },
  { "tcsini16", 0, 16 }, { "tcsini17", 0, 17 }, { "tcsini18", 0, 18 },
  { "tcsini19", 0, 19 }, { "tcsini20", 0, 20 }, { "tcsini21", 0, 21 },
  { "tcsini22", 0, 22 }, { "tcsini23", 0, 23 }, { "tcsini24", 0, 24 },
  { "tcsini25", 0, 25 }, { "tcsini26", 0, 26 }, { "tcsini27", 0, 27 },
  { "tcsini28", 0, 28 }, { "tcsini29", 0, 29 }, { "tcsini30", 0, 30 },
  { "tcsini31", 0, 31 }, { "tcsini32", 0, 32 }, { "tcsini33", 0, 33 },
  { "tcsini34", 0, 34 }, { "tcsini35", 0, 35 }, { "tcsini36", 0, 36 },
  { "tcsini37", 0, 37 }, { "tcsini38", 0, 38 }, { "tcsini39", 0, 39 },
  { "tcsini40", 0, 40 }, { "tcsini41", 0, 41 }, { "tcsini42", 0, 42 },
  { "tcsini43", 0, 43 }, { "tcsini44", 0, 44 }, { "tcsini45", 0, 45 },
  { "tcsini46", 0, 46 }, { "tcsini47", 0, 47 }, { "tcsini48", 0, 48 },
  { "tcsini49", 0, 49 }, { "tcsini50", 0, 50 }, { "tcsini51", 0, 51 },
  { "tcsini52", 0, 52 }, { "tcsini53", 0, 53 }, { "tcsini54", 0, 54 },
  { "tcsini55", 0, 55 }, { "tcsini56", 0, 56 }, { "tcsini57", 0, 57 },
  { "tcsini58", 0, 58 }, { "tcsini59", 0, 59 }, { "tcsini60", 0, 60 },
  { "tcsini61", 0, 61 }, { "tcsini62", 0, 62 }, { "tcsini63", 0, 63 },
  { "tcsini64", 0, 64 }, { "vis0", 0, 65 }, { "vis1", 0, 66 },
  { "vis2", 0, 67 } };

static sdramaddr_t sdramAddrBase[]= { /* indexed by node number */
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00, 0x14d00,
  0x14d00, /* tcsini0 through tcsini64 */
  0x13d00, 0x13d00, 0x13d00, /* vis0 through vis2 */
};

static E3_Addr elanAddrBase[]= { /* indexed by node number */
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400,0x405400, 
  0x405400, /* tcsini0 through tcsini64 */
  0x403400, 0x403400, 0x403400, /* vis0 through vis2 */
};

#endif

static host_t hosts[] = { 
  {"iam0",0,0}, {"iam1",0,1}, {"iam2",0,2}, {"iam3",0,3}, 
  {"iam4",0,4}, {"iam5",0,5}, {"iam6",0,6}, {"iam7",0,7}, 
  {"iam8",0,8}, {"iam9",0,9}, {"iam10",0,10}, {"iam11",0,11}, 
  {"iam12",0,12}, {"iam13",0,13}, {"iam14",0,14}, {"iam15",0,15}, 
  {"iam16",0,16}, {"iam17",0,17}, {"iam18",0,18}, {"iam19",0,19}, 
  {"iam20",0,20}, {"iam21",0,21}, {"iam22",0,22}, {"iam23",0,23}, 
  {"iam24",0,24}, {"iam25",0,25}, {"iam26",0,26}, {"iam27",0,27}, 
  {"iam28",0,28}, {"iam29",0,29}, {"iam30",0,30}, {"iam31",0,31}, 
  {"iam32",0,32}, {"iam33",0,33}, {"iam34",0,34}, {"iam35",0,35}, 
  {"iam36",0,36}, {"iam37",0,37}, {"iam38",0,38}, {"iam39",0,39}, 
  {"iam40",0,40}, {"iam41",0,41}, {"iam42",0,42}, {"iam43",0,43}, 
  {"iam44",0,44}, {"iam45",0,45}, {"iam46",0,46}, {"iam47",0,47}, 
  {"iam48",0,48}, {"iam49",0,49}, {"iam50",0,50}, {"iam51",0,51}, 
  {"iam52",0,52}, {"iam53",0,53}, {"iam54",0,54}, {"iam55",0,55}, 
  {"iam56",0,56}, {"iam57",0,57}, {"iam58",0,58}, {"iam59",0,59}, 
  {"iam60",0,60}, {"iam61",0,61}, {"iam62",0,62}, {"iam63",0,63}, 
  {"iam64",0,64}, {"iam65",0,65}, {"iam66",0,66}, {"iam67",0,67}, 
  {"iam68",0,68}, {"iam69",0,69}, {"iam70",0,70}, {"iam71",0,71}, 
  {"iam72",0,72}, {"iam73",0,73}, {"iam74",0,74}, {"iam75",0,75}, 
  {"iam76",0,76}, {"iam77",0,77}, {"iam78",0,78}, {"iam79",0,79}, 
  {"iam80",0,80}, {"iam81",0,81}, {"iam82",0,82}, {"iam83",0,83}, 
  {"iam84",0,84}, {"iam85",0,85}, {"iam86",0,86}, {"iam87",0,87}, 
  {"iam88",0,88}, {"iam89",0,89}, {"iam90",0,90}, {"iam91",0,91}, 
  {"iam92",0,92}, {"iam93",0,93}, {"iam94",0,94}, {"iam95",0,95}, 
  {"iam96",0,96}, {"iam97",0,97}, {"iam98",0,98}, {"iam99",0,99}, 
  {"iam100",0,100}, {"iam101",0,101}, {"iam102",0,102}, {"iam103",0,103}, 
  {"iam104",0,104}, {"iam105",0,105}, {"iam106",0,106}, {"iam107",0,107}, 
  {"iam108",0,108}, {"iam109",0,109}, {"iam110",0,110}, {"iam111",0,111}, 
  {"iam112",0,112}, {"iam113",0,113}, {"iam114",0,114}, {"iam115",0,115}, 
  {"iam116",0,116}, {"iam117",0,117}, {"iam118",0,118}, {"iam119",0,119}, 
  {"iam120",0,120}, {"iam121",0,121}, {"iam122",0,122}, {"iam123",0,123}, 
  {"iam124",0,124}, {"iam125",0,125}, {"iam126",0,126}, {"iam127",0,127}, 
  {"iam128",0,128}, {"iam129",0,129}, {"iam130",0,130}, {"iam131",0,131}, 
  {"iam132",0,132}, {"iam133",0,133}, {"iam134",0,134}, {"iam135",0,135}, 
  {"iam136",0,136}, {"iam137",0,137}, {"iam138",0,138}, {"iam139",0,139}, 
  {"iam140",0,140}, {"iam141",0,141}, {"iam142",0,142}, {"iam143",0,143}, 
  {"iam144",0,144}, {"iam145",0,145}, {"iam146",0,146}, {"iam147",0,147}, 
  {"iam148",0,148}, {"iam149",0,149}, {"iam150",0,150}, {"iam151",0,151}, 
  {"iam152",0,152}, {"iam153",0,153}, {"iam154",0,154}, {"iam155",0,155}, 
  {"iam156",0,156}, {"iam157",0,157}, {"iam158",0,158}, {"iam159",0,159}, 
  {"iam160",0,160}, {"iam161",0,161}, {"iam162",0,162}, {"iam163",0,163}, 
  {"iam164",0,164}, {"iam165",0,165}, {"iam166",0,166}, {"iam167",0,167}, 
  {"iam168",0,168}, {"iam169",0,169}, {"iam170",0,170}, {"iam171",0,171}, 
  {"iam172",0,172}, {"iam173",0,173}, {"iam174",0,174}, {"iam175",0,175}, 
  {"iam176",0,176}, {"iam177",0,177}, {"iam178",0,178}, {"iam179",0,179}, 
  {"iam180",0,180}, {"iam181",0,181}, {"iam182",0,182}, {"iam183",0,183}, 
  {"iam184",0,184}, {"iam185",0,185}, {"iam186",0,186}, {"iam187",0,187}, 
  {"iam188",0,188}, {"iam189",0,189}, {"iam190",0,190}, {"iam191",0,191}, 
  {"iam192",0,192}, {"iam193",0,193}, {"iam194",0,194}, {"iam195",0,195}, 
  {"iam196",0,196}, {"iam197",0,197}, {"iam198",0,198}, {"iam199",0,199}, 
  {"iam200",0,200}, {"iam201",0,201}, {"iam202",0,202}, {"iam203",0,203}, 
  {"iam204",0,204}, {"iam205",0,205}, {"iam206",0,206}, {"iam207",0,207}, 
  {"iam208",0,208}, {"iam209",0,209}, {"iam210",0,210}, {"iam211",0,211}, 
  {"iam212",0,212}, {"iam213",0,213}, {"iam214",0,214}, {"iam215",0,215}, 
  {"iam216",0,216}, {"iam217",0,217}, {"iam218",0,218}, {"iam219",0,219}, 
  {"iam220",0,220}, {"iam221",0,221}, {"iam222",0,222}, {"iam223",0,223}, 
  {"iam224",0,224}, {"iam225",0,225}, {"iam226",0,226}, {"iam227",0,227}, 
  {"iam228",0,228}, {"iam229",0,229}, {"iam230",0,230}, {"iam231",0,231}, 
  {"iam232",0,232}, {"iam233",0,233}, {"iam234",0,234}, {"iam235",0,235}, 
  {"iam236",0,236}, {"iam237",0,237}, {"iam238",0,238}, {"iam239",0,239}, 
  {"iam240",0,240}, {"iam241",0,241}, {"iam242",0,242}, {"iam243",0,243}, 
  {"iam244",0,244}, {"iam245",0,245}, {"iam246",0,246}, {"iam247",0,247}, 
  {"iam248",0,248}, {"iam249",0,249}, {"iam250",0,250}, {"iam251",0,251}, 
  {"iam252",0,252}, {"iam253",0,253}, {"iam254",0,254}, {"iam255",0,255}, 
  {"iam256",0,256}, {"iam257",0,257}, {"iam258",0,258}, {"iam259",0,259}, 
  {"iam260",0,260}, {"iam261",0,261}, {"iam262",0,262}, {"iam263",0,263}, 
  {"iam264",0,264}, {"iam265",0,265}, {"iam266",0,266}, {"iam267",0,267}, 
  {"iam268",0,268}, {"iam269",0,269}, {"iam270",0,270}, {"iam271",0,271}, 
  {"iam272",0,272}, {"iam273",0,273}, {"iam274",0,274}, {"iam275",0,275}, 
  {"iam276",0,276}, {"iam277",0,277}, {"iam278",0,278}, {"iam279",0,279}, 
  {"iam280",0,280}, {"iam281",0,281}, {"iam282",0,282}, {"iam283",0,283}, 
  {"iam284",0,284}, {"iam285",0,285}, {"iam286",0,286}, {"iam287",0,287}, 
  {"iam288",0,288}, {"iam289",0,289}, {"iam290",0,290}, {"iam291",0,291}, 
  {"iam292",0,292}, {"iam293",0,293}, {"iam294",0,294}, {"iam295",0,295}, 
  {"iam296",0,296}, {"iam297",0,297}, {"iam298",0,298}, {"iam299",0,299}, 
  {"iam300",0,300}, {"iam301",0,301}, {"iam302",0,302}, {"iam303",0,303}, 
  {"iam304",0,304}, {"iam305",0,305}, {"iam306",0,306}, {"iam307",0,307}, 
  {"iam308",0,308}, {"iam309",0,309}, {"iam310",0,310}, {"iam311",0,311}, 
  {"iam312",0,312}, {"iam313",0,313}, {"iam314",0,314}, {"iam315",0,315}, 
  {"iam316",0,316}, {"iam317",0,317}, {"iam318",0,318}, {"iam319",0,319}, 
  {"iam320",0,320}, {"iam321",0,321}, {"iam322",0,322}, {"iam323",0,323}, 
  {"iam324",0,324}, {"iam325",0,325}, {"iam326",0,326}, {"iam327",0,327}, 
  {"iam328",0,328}, {"iam329",0,329}, {"iam330",0,330}, {"iam331",0,331}, 
  {"iam332",0,332}, {"iam333",0,333}, {"iam334",0,334}, {"iam335",0,335}, 
  {"iam336",0,336}, {"iam337",0,337}, {"iam338",0,338}, {"iam339",0,339}, 
  {"iam340",0,340}, {"iam341",0,341}, {"iam342",0,342}, {"iam343",0,343}, 
  {"iam344",0,344}, {"iam345",0,345}, {"iam346",0,346}, {"iam347",0,347}, 
  {"iam348",0,348}, {"iam349",0,349}, {"iam350",0,350}, {"iam351",0,351}, 
  {"iam352",0,352}, {"iam353",0,353}, {"iam354",0,354}, {"iam355",0,355}, 
  {"iam356",0,356}, {"iam357",0,357}, {"iam358",0,358}, {"iam359",0,359}, 
  {"iam360",0,360}, {"iam361",0,361}, {"iam362",0,362}, {"iam363",0,363}, 
  {"iam364",0,364}, {"iam365",0,365}, {"iam366",0,366}, {"iam367",0,367}, 
  {"iam368",0,368}, {"iam369",0,369}, {"iam370",0,370}, {"iam371",0,371}, 
  {"iam372",0,372}, {"iam373",0,373}, {"iam374",0,374}, {"iam375",0,375}, 
  {"iam376",0,376}, {"iam377",0,377}, {"iam378",0,378}, {"iam379",0,379}, 
  {"iam380",0,380}, {"iam381",0,381}, {"iam382",0,382}, {"iam383",0,383}, 
  {"iam384",0,384}, {"iam385",0,385}, {"iam386",0,386}, {"iam387",0,387}, 
  {"iam388",0,388}, {"iam389",0,389}, {"iam390",0,390}, {"iam391",0,391}, 
  {"iam392",0,392}, {"iam393",0,393}, {"iam394",0,394}, {"iam395",0,395}, 
  {"iam396",0,396}, {"iam397",0,397}, {"iam398",0,398}, {"iam399",0,399}, 
  {"iam400",0,400}, {"iam401",0,401}, {"iam402",0,402}, {"iam403",0,403}, 
  {"iam404",0,404}, {"iam405",0,405}, {"iam406",0,406}, {"iam407",0,407}, 
  {"iam408",0,408}, {"iam409",0,409}, {"iam410",0,410}, {"iam411",0,411}, 
  {"iam412",0,412}, {"iam413",0,413}, {"iam414",0,414}, {"iam415",0,415}, 
  {"iam416",0,416}, {"iam417",0,417}, {"iam418",0,418}, {"iam419",0,419}, 
  {"iam420",0,420}, {"iam421",0,421}, {"iam422",0,422}, {"iam423",0,423}, 
  {"iam424",0,424}, {"iam425",0,425}, {"iam426",0,426}, {"iam427",0,427}, 
  {"iam428",0,428}, {"iam429",0,429}, {"iam430",0,430}, {"iam431",0,431}, 
  {"iam432",0,432}, {"iam433",0,433}, {"iam434",0,434}, {"iam435",0,435}, 
  {"iam436",0,436}, {"iam437",0,437}, {"iam438",0,438}, {"iam439",0,439}, 
  {"iam440",0,440}, {"iam441",0,441}, {"iam442",0,442}, {"iam443",0,443}, 
  {"iam444",0,444}, {"iam445",0,445}, {"iam446",0,446}, {"iam447",0,447}, 
  {"iam448",0,448}, {"iam449",0,449}, {"iam450",0,450}, {"iam451",0,451}, 
  {"iam452",0,452}, {"iam453",0,453}, {"iam454",0,454}, {"iam455",0,455}, 
  {"iam456",0,456}, {"iam457",0,457}, {"iam458",0,458}, {"iam459",0,459}, 
  {"iam460",0,460}, {"iam461",0,461}, {"iam462",0,462}, {"iam463",0,463}, 
  {"iam464",0,464}, {"iam465",0,465}, {"iam466",0,466}, {"iam467",0,467}, 
  {"iam468",0,468}, {"iam469",0,469}, {"iam470",0,470}, {"iam471",0,471}, 
  {"iam472",0,472}, {"iam473",0,473}, {"iam474",0,474}, {"iam475",0,475}, 
  {"iam476",0,476}, {"iam477",0,477}, {"iam478",0,478}, {"iam479",0,479}, 
  {"iam480",0,480}, {"iam481",0,481}, {"iam482",0,482}, {"iam483",0,483}, 
  {"iam484",0,484}, {"iam485",0,485}, {"iam486",0,486}, {"iam487",0,487}, 
  {"iam488",0,488}, {"iam489",0,489}, {"iam490",0,490}, {"iam491",0,491}, 
  {"iam492",0,492}, {"iam493",0,493}, {"iam494",0,494}, {"iam495",0,495}, 
  {"iam496",0,496}, {"iam497",0,497}, {"iam498",0,498}, {"iam499",0,499}, 
  {"iam500",0,500}, {"iam501",0,501}, {"iam502",0,502}, {"iam503",0,503}, 
  {"iam504",0,504}, {"iam505",0,505}, {"iam506",0,506}, {"iam507",0,507}, 
  {"iam508",0,508}, {"iam509",0,509}, {"iam510",0,510}, {"iam511",0,511}, 
  {"iam512",0,512}, {"iam513",0,513}, {"iam514",0,514}, {"iam515",0,515}, 
  {"iam516",0,516}, {"iam517",0,517}, {"iam518",0,518}, {"iam519",0,519}, 
  {"iam520",0,520}, {"iam521",0,521}, {"iam522",0,522}, {"iam523",0,523}, 
  {"iam524",0,524}, {"iam525",0,525}, {"iam526",0,526}, {"iam527",0,527}, 
  {"iam528",0,528}, {"iam529",0,529}, {"iam530",0,530}, {"iam531",0,531}, 
  {"iam532",0,532}, {"iam533",0,533}, {"iam534",0,534}, {"iam535",0,535}, 
  {"iam536",0,536}, {"iam537",0,537}, {"iam538",0,538}, {"iam539",0,539}, 
  {"iam540",0,540}, {"iam541",0,541}, {"iam542",0,542}, {"iam543",0,543}, 
  {"iam544",0,544}, {"iam545",0,545}, {"iam546",0,546}, {"iam547",0,547}, 
  {"iam548",0,548}, {"iam549",0,549}, {"iam550",0,550}, {"iam551",0,551}, 
  {"iam552",0,552}, {"iam553",0,553}, {"iam554",0,554}, {"iam555",0,555}, 
  {"iam556",0,556}, {"iam557",0,557}, {"iam558",0,558}, {"iam559",0,559}, 
  {"iam560",0,560}, {"iam561",0,561}, {"iam562",0,562}, {"iam563",0,563}, 
  {"iam564",0,564}, {"iam565",0,565}, {"iam566",0,566}, {"iam567",0,567}, 
  {"iam568",0,568}, {"iam569",0,569}, {"iam570",0,570}, {"iam571",0,571}, 
  {"iam572",0,572}, {"iam573",0,573}, {"iam574",0,574}, {"iam575",0,575}, 
  {"iam576",0,576}, {"iam577",0,577}, {"iam578",0,578}, {"iam579",0,579}, 
  {"iam580",0,580}, {"iam581",0,581}, {"iam582",0,582}, {"iam583",0,583}, 
  {"iam584",0,584}, {"iam585",0,585}, {"iam586",0,586}, {"iam587",0,587}, 
  {"iam588",0,588}, {"iam589",0,589}, {"iam590",0,590}, {"iam591",0,591}, 
  {"iam592",0,592}, {"iam593",0,593}, {"iam594",0,594}, {"iam595",0,595}, 
  {"iam596",0,596}, {"iam597",0,597}, {"iam598",0,598}, {"iam599",0,599}, 
  {"iam600",0,600}, {"iam601",0,601}, {"iam602",0,602}, {"iam603",0,603}, 
  {"iam604",0,604}, {"iam605",0,605}, {"iam606",0,606}, {"iam607",0,607}, 
  {"iam608",0,608}, {"iam609",0,609}, {"iam610",0,610}, {"iam611",0,611}, 
  {"iam612",0,612}, {"iam613",0,613}, {"iam614",0,614}, {"iam615",0,615}, 
  {"iam616",0,616}, {"iam617",0,617}, {"iam618",0,618}, {"iam619",0,619}, 
  {"iam620",0,620}, {"iam621",0,621}, {"iam622",0,622}, {"iam623",0,623}, 
  {"iam624",0,624}, {"iam625",0,625}, {"iam626",0,626}, {"iam627",0,627}, 
  {"iam628",0,628}, {"iam629",0,629}, {"iam630",0,630}, {"iam631",0,631}, 
  {"iam632",0,632}, {"iam633",0,633}, {"iam634",0,634}, {"iam635",0,635}, 
  {"iam636",0,636}, {"iam637",0,637}, {"iam638",0,638}, {"iam639",0,639}, 
  {"iam640",0,640}, {"iam641",0,641}, {"iam642",0,642}, {"iam643",0,643}, 
  {"iam644",0,644}, {"iam645",0,645}, {"iam646",0,646}, {"iam647",0,647}, 
  {"iam648",0,648}, {"iam649",0,649}, {"iam650",0,650}, {"iam651",0,651}, 
  {"iam652",0,652}, {"iam653",0,653}, {"iam654",0,654}, {"iam655",0,655}, 
  {"iam656",0,656}, {"iam657",0,657}, {"iam658",0,658}, {"iam659",0,659}, 
  {"iam660",0,660}, {"iam661",0,661}, {"iam662",0,662}, {"iam663",0,663}, 
  {"iam664",0,664}, {"iam665",0,665}, {"iam666",0,666}, {"iam667",0,667}, 
  {"iam668",0,668}, {"iam669",0,669}, {"iam670",0,670}, {"iam671",0,671}, 
  {"iam672",0,672}, {"iam673",0,673}, {"iam674",0,674}, {"iam675",0,675}, 
  {"iam676",0,676}, {"iam677",0,677}, {"iam678",0,678}, {"iam679",0,679}, 
  {"iam680",0,680}, {"iam681",0,681}, {"iam682",0,682}, {"iam683",0,683}, 
  {"iam684",0,684}, {"iam685",0,685}, {"iam686",0,686}, {"iam687",0,687}, 
  {"iam688",0,688}, {"iam689",0,689}, {"iam690",0,690}, {"iam691",0,691}, 
  {"iam692",0,692}, {"iam693",0,693}, {"iam694",0,694}, {"iam695",0,695}, 
  {"iam696",0,696}, {"iam697",0,697}, {"iam698",0,698}, {"iam699",0,699}, 
  {"iam700",0,700}, {"iam701",0,701}, {"iam702",0,702}, {"iam703",0,703}, 
  {"iam704",0,704}, {"iam705",0,705}, {"iam706",0,706}, {"iam707",0,707}, 
  {"iam708",0,708}, {"iam709",0,709}, {"iam710",0,710}, {"iam711",0,711}, 
  {"iam712",0,712}, {"iam713",0,713}, {"iam714",0,714}, {"iam715",0,715}, 
  {"iam716",0,716}, {"iam717",0,717}, {"iam718",0,718}, {"iam719",0,719}, 
  {"iam720",0,720}, {"iam721",0,721}, {"iam722",0,722}, {"iam723",0,723}, 
  {"iam724",0,724}, {"iam725",0,725}, {"iam726",0,726}, {"iam727",0,727}, 
  {"iam728",0,728}, {"iam729",0,729}, {"iam730",0,730}, {"iam731",0,731}, 
  {"iam732",0,732}, {"iam733",0,733}, {"iam734",0,734}, {"iam735",0,735}, 
  {"iam736",0,736}, {"iam737",0,737}, {"iam738",0,738}, {"iam739",0,739}, 
  {"iam740",0,740}, {"iam741",0,741}, {"iam742",0,742}, {"iam743",0,743}, 
  {"iam744",0,744}, {"iam745",0,745}, {"iam746",0,746}, {"iam747",0,747}, 
  {"iam748",0,748}, {"iam749",0,749}, {"iam750",0,750}, {"iam751",0,751}, 
  {"iam752",0,752}, {"iam753",0,753}, {"iam754",0,754}, {"iam755",0,755}, 
  {"iam756",0,756}, {"iam757",0,757}, {"iam758",0,758}, {"iam759",0,759}, 
  {"iam760",0,760}, {"iam761",0,761}, {"iam762",0,762}, {"iam763",0,763}, 
  {"iam764",0,764}, /* iam0 through iam765 */
  {"dummy0",0,765}, {"dummy0",0,766}, {"dummy0",0,767}, /* 3 open ports */
  { "tcsvis0", 0, 768 }, { "tcsvis1", 0, 769 }, { "tcsvis2", 0, 770 },
  { "tcsvis3", 0, 771 } 
};

static sdramaddr_t sdramAddrBase[]= { /* indexed by node number */
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700, 0x15700,
  0x15700, 0x15700, 0x15700, 0x15700, 0x15700, /* iam0 through iam764 */
  0x00000, 0x00000, 0x00000, /* three open ports */
  0x13700, 0x13700, 0x13700, 0x13700, /* tcsvis0 through tcsvis3*/

};

static E3_Addr elanAddrBase[]= { /* indexed by node number */
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,0x405c00,
  0x405c00,0x405c00,0x405c00,0x405c00,0x405c00, /* iam0 through iam764 */
  0x000000, 0x000000, 0x000000, /* three open ports */
  0x404c00, 0x404c00, 0x404c00, 0x404c00, /* tcsvis0 through tcsvis3 */
};


#define MAXHOSTS (sizeof(hosts)/sizeof(host_t))

#define MAXPORTS (sizeof(sdramAddrBase)/sizeof(sdramaddr_t))

static int trans_host(const char *hn)  {
  int   i;
  int   j;
  for (i=0; i<MAXHOSTS; i++)  {
    int match= 1;
    for (j=0; (hn[j]!='\0' && hn[j]!='.'); j++) {
      if (hn[j] != hosts[i].name[j]) {
        match= 0;
        break;
      }
    }
    if (match) return(hosts[i].id);
  }
  return(-1);
}

/*
 * A version of address translation with some safety checks
 */
static E3_Addr teac_main2elan( ELAN3_CTX *ctx, void* main_addr )
{
  E3_Addr result= elan3_main2elan(ctx,main_addr);
  /*
  fprintf(stderr,"mapping %0lx -> %d; addressable %d\n",
	  main_addr,result,elan3_addressable(ctx,main_addr,64));
  */
  if (result==ELAN_BAD_ADDR) {
    fprintf(stderr,"Address translation error: %0x has no elan equivalent\n",
	    (int)main_addr);
    exit(-1);
  }
  return result;
}

Tcomm *teac_Init(char *lh, char *hh, int lctx, int hctx, int myrank)
{
  ELAN3_DEVINFO	info;
  ELAN_CAPABILITY *cap;
  Tcomm* result= NULL;
  int i;
  int j;
  int a;
  int b;
  char buf[256];
  char* here;
#ifdef __linux__
#ifdef ELAN_PRE_KITE
  void* control;
#endif
#endif

  if (!(result= (Tcomm*)crAlloc(sizeof(Tcomm)))) {
    fprintf(stderr,"teac_Init: unable to allocate %d bytes!\n",
	    sizeof(Tcomm));
    return(NULL);
  }
  result->ctx = NULL;
  result->dma = NULL;
  result->e_dma = 0;
  result->s_event = 0;
  result->r_event = NULL;
  for (i=0; i<NUM_SEND_BUFFERS; i++) result->sbuf_pull_event[i] = 0;
  result->rbuf_pull_event = 0;
  result->m_snd = NULL;
  result->m_rcv = NULL;
  for (i=0; i<NUM_SEND_BUFFERS; i++) result->sbuf_ready[i]= NULL;
  result->rbuf_ready = NULL;
  result->mbuff= NULL;
  for (i=0; i<NUM_SEND_BUFFERS; i++) result->sendWrappers[i]= NULL;
  result->vp = -1;
  result->hhost = result->lhost = -1;
  result->hctx = result->lctx = -1;
  result->msgnum = 0;
  result->poll_shift = 0;
      
  a = trans_host(lh);
  b = trans_host(hh);
  result->lhost = (a < b)? a : b;
  result->hhost = (a > b) ? a : b;
  
  result->lctx = (lctx<hctx) ? lctx : hctx;
  result->hctx = (hctx>lctx) ? hctx : lctx;
  
  cap = &(result->cap);
  elan3_nullcap(cap);
  
  /* Initialize the UserKey to a random number */
  crStrncpy((char*)&(cap->UserKey), "This is pretty random!", 
	  sizeof(ELAN_USERKEY));
  cap->LowContext = lctx;
  cap->MyContext = lctx + (myrank%4);
  cap->HighContext = hctx;
  cap->LowNode = result->lhost;
  cap->HighNode = result->hhost;
  cap->Entries = (hctx - lctx + 1) * (cap->HighNode - cap->LowNode + 1);
  cap->Type = 
    ELAN_CAP_TYPE_BLOCK | ELAN_CAP_TYPE_NO_BITMAP | ELAN_CAP_TYPE_MULTI_RAIL;
  
  if ((result->ctx = elan3_init( 0, EADDR_ALLOC_MAIN, ALLOC_MAIN_SIZE, 
				 EADDR_ALLOC_ELAN, ALLOC_ELAN_SIZE))
      == NULL)  {
    fprintf(stderr, "teac_Init: elan3_init returned NULL context\n");
    return(NULL);
  }
  elan3_block_inputter (result->ctx, 1);
  
#ifdef __linux__
#ifdef ELAN_PRE_KITE
  if ((control = elan3_control_open (RAIL)) != NULL)  {
    if (elan3_create(control, &(result->cap)))  {
      fprintf(stderr, "elan3_create failed with <%s>, but that's OK!\n",
	      strerror(errno));
      errno= 0;
    }
  }  
  else  {
    perror("elan3_control_open failed");
    teac_Close(result);
    return NULL;
  }                                                                       
#else
  if (elan3_create(result->ctx, &(result->cap)))  {
    fprintf(stderr, "elan3_create failed with <%s>, but that's OK!\n",
	    strerror(errno));
    errno= 0;
  }
#endif
#else
  if (elan3_create(result->ctx, &(result->cap)))  {
    fprintf(stderr, "elan3_create failed with <%s>, but that's OK!\n",
	    strerror(errno));
    errno= 0;
  }
#endif

  elan3_devinfo(0, &info);
  /*
    The above call for rail '0' yields the following info:
    - info.NodeId
    - info.NumLevels
    - info.NodeLevel
  */

#ifdef __linux__
#ifdef ELAN_PRE_KITE
  fprintf(stdout, "NodeId: %d, NumLevels: %d, NodeLevel: %d\n",
	  info.NodeId, info.NumLevels, info.NodeLevel);
#else
  fprintf(stdout, "NodeId: %d, NumLevels: %d, NodeLevel: %d\n",
	  info.Position.NodeId, info.Position.NumLevels, 
	  info.Position.NodeLevel);
#endif
#else
  fprintf(stdout, "NodeId: %d, NumLevels: %d, NodeLevel: %d\n",
	  info.NodeId, info.NumLevels, info.NodeLevel);
#endif

#ifdef never
  fprintf(stderr,"Capability: <%s>\n",
          elan3_capability_string(&(result->cap),junkString));
  fprintf(stderr,"railmask is %d\n",result->cap.RailMask);
  fprintf(stderr,"bitmap is %x\n",result->cap.Bitmap[0]);

#endif

  /* Reality check. */
  if (gethostname(buf,sizeof(buf)-1)) {
    perror("Can't get my own host name");
    teac_Close(result);
    return NULL;
  }
  if ((here= crStrchr(buf,'.')) != NULL) *here= '\0';
#ifdef __linux__
#ifdef ELAN_PRE_KITE
  if (trans_host(buf) != info.NodeId) {
    fprintf(stderr,
 "teac_Init: compiled-in Quadrics port id %d does not match real value %d!\n",
	    trans_host(buf), info.NodeId);
    teac_Close(result);
    return NULL;
  }
#else
  if (trans_host(buf) != info.Position.NodeId) {
    fprintf(stderr,
 "teac_Init: compiled-in Quadrics port id %d does not match real value %d!\n",
	    trans_host(buf), info.Position.NodeId);
    teac_Close(result);
    return NULL;
  }
#endif
#else
  if (trans_host(buf) != info.NodeId) {
    fprintf(stderr,
 "teac_Init: compiled-in Quadrics port id %d does not match real value %d!\n",
	    trans_host(buf), info.NodeId);
    teac_Close(result);
    return NULL;
  }
#endif

  if (elan3_attach(result->ctx, &(result->cap)))  {
    fprintf(stderr, "teac_Init: elan3_attach failed\n");
    teac_Close(result);
    return(NULL);
  }

  if (elan3_addvp(result->ctx, 0, &(result->cap)))  {
    fprintf(stderr, "teac_Init: elan3_addvp failed\n");
    teac_Close(result);
    return(NULL);
  }
  
  result->vp = elan3_process(result->ctx);
  
  if (! elan3_set_required_mappings (result->ctx))  {
    fprintf(stderr, "teac_Init: elan3_set_required_mappings failed\n");
    teac_Close(result);
    return(NULL);
  }
  
  if (!(result->r_event= 
	(sdramaddr_t**)crAlloc( cap->Entries*sizeof(sdramaddr_t*) ))) {
    fprintf(stderr,"teac_Init: unable to allocate %d bytes!\n",
	    cap->Entries*sizeof(sdramaddr_t*));
    teac_Close(result);
    return(NULL);
  }
  if (!(result->r_event[0]=
	(sdramaddr_t*)crAlloc( cap->Entries*NUM_SEND_BUFFERS
			      * sizeof(sdramaddr_t) ))) {
    fprintf(stderr,"teac_Init: unable to allocate %d bytes!\n",
	    cap->Entries*NUM_SEND_BUFFERS*sizeof(sdramaddr_t));
    teac_Close(result);
    return(NULL);
  }
  if (!(result->r_event[0][0]=
	elan3_allocElan(result->ctx, E3_EVENT_ALIGN, 
		cap->Entries*NUM_SEND_BUFFERS*sizeof(E3_BlockCopyEvent)))) {
    perror("teac_Init: elan3_allocElan failed for r_event block");
    teac_Close(result);
    return(NULL);
  }
  for (j=1; j<cap->Entries; j++) {
    result->r_event[j]= result->r_event[0] + j*NUM_SEND_BUFFERS;
    result->r_event[j][0]= 
      result->r_event[0][0]+j*NUM_SEND_BUFFERS*sizeof(E3_BlockCopyEvent);
  }
  for (j=0; j<cap->Entries; j++) 
    for (i=1; i<NUM_SEND_BUFFERS; i++) {
      result->r_event[j][i]= 
	result->r_event[j][0] + i*sizeof(E3_BlockCopyEvent);
    }
#ifdef never
  fprintf(stderr,"r_event[0][0] is %x\n",(int)result->r_event[0][0]);
#endif

  if (!(result->m_rcv= 
	(volatile E3_uint32**)crAlloc( cap->Entries*sizeof(E3_uint32*) ))) {
    fprintf(stderr,"teac_Init: unable to allocate %d bytes!\n",
	    cap->Entries*sizeof(E3_uint32*));
    teac_Close(result);
    return(NULL);
  }
  if (!(result->m_rcv[0]= (volatile E3_uint32*)
	elan3_allocMain(result->ctx, 0, 
			cap->Entries*NUM_SEND_BUFFERS*sizeof(E3_uint32)))) {
    perror("teac_Init: elan3_allocMain failed for m_rcv block");
    teac_Close(result);
    return(NULL);
  }
  for (i=1; i<cap->Entries; i++)
    result->m_rcv[i]= result->m_rcv[0] + i*NUM_SEND_BUFFERS;
#ifdef never
  fprintf(stderr,"Base of m_rcv is %lx -> %lx\n",
	  (long)(result->m_rcv[0]),
	  (long)teac_main2elan(result->ctx,(void*)(result->m_rcv[0])));
#endif
  
  if (!(result->mbuff= (teacMsg**)crAlloc( cap->Entries*sizeof(teacMsg*) ))) {
    fprintf(stderr,"teac_Init: unable to allocate %d bytes!\n",
	    cap->Entries*sizeof(teacMsg*));
    teac_Close(result);
    return(NULL);
  }
  if (!(result->mbuff[0]= (teacMsg*)
	elan3_allocMain(result->ctx, 8, 
			cap->Entries*NUM_SEND_BUFFERS*sizeof(teacMsg)))) {
    perror("teac_Init: elan3_allocMain failed for mbuff block");
    teac_Close(result);
    return(NULL);
  }
  for (i=1; i<cap->Entries; i++)
    result->mbuff[i]= result->mbuff[0] + i*NUM_SEND_BUFFERS;
#ifdef never
  fprintf(stderr,"Base of mbuff is %lx -> %lx\n",
	  (long)(result->mbuff[0]), 
	  (long)teac_main2elan(result->ctx,result->mbuff[0]));
#endif
  
  if (!(result->dma= (E3_DMA_MAIN *)
	elan3_allocMain(result->ctx, 
			E3_DMA_ALIGN, sizeof(E3_DMA_MAIN)))) {
    perror("teac_Init: elan3_allocMain failed for dma");
    teac_Close(result);
    return(NULL);
  }
  
  if (!(result->e_dma= 
	elan3_allocElan(result->ctx, E3_DMA_ALIGN, sizeof(E3_DMA)))) {
    perror("teac_Init: elan3_allocElan failed for e_dma");
    teac_Close(result);
    return(NULL);
  }
  
  if (!(result->s_event= 
	elan3_allocElan(result->ctx, E3_EVENT_ALIGN, 
			sizeof(E3_BlockCopyEvent)))) {
    perror("teac_Init: elan3_allocElan failed for s_event");
    teac_Close(result);
    return(NULL);
  }
#ifdef never
  fprintf(stderr,"s_event is %x\n",(int)result->s_event);
#endif
  
  if (!(result->sbuf_pull_event[0]= 
	elan3_allocElan(result->ctx, E3_EVENT_ALIGN, 
			NUM_SEND_BUFFERS*sizeof(E3_BlockCopyEvent)))) {
    perror("teac_Init: elan3_allocElan failed for sbuf_pull_event block");
    teac_Close(result);
    return(NULL);
  }
  for (i=1; i<NUM_SEND_BUFFERS; i++) 
    result->sbuf_pull_event[i]= 
      result->sbuf_pull_event[0]+i*sizeof(E3_BlockCopyEvent);
  
  if (!(result->rbuf_pull_event= 
	elan3_allocElan(result->ctx, E3_EVENT_ALIGN, 
			sizeof(E3_BlockCopyEvent)))) {
    perror("teac_Init: elan3_allocElan failed for rbuf_pull_event");
    teac_Close(result);
    return(NULL);
  }
  
  if (!(result->m_snd= (E3_uint32 *)
	elan3_allocMain(result->ctx, 0, 
			sizeof(E3_uint32)))) {
    perror("teac_Init: elan3_allocMain failed for m_snd");
    teac_Close(result);
    return(NULL);
  }

  if (!(result->sbuf_ready[0]= (E3_uint32 *)
	elan3_allocMain(result->ctx, 0, 
			NUM_SEND_BUFFERS*sizeof(E3_uint32)))) {
    perror("teac_Init: elan3_allocMain failed for sbuf_ready block");
    teac_Close(result);
    return(NULL);
  }
  for (i=1; i<NUM_SEND_BUFFERS; i++)
    result->sbuf_ready[i]= result->sbuf_ready[0] + i;
  
  if (!(result->sendWrappers[0]= 
	(SBuffer*)crAlloc(NUM_SEND_BUFFERS*sizeof(SBuffer)))) {
    fprintf(stderr,"teac_Init: unable to allocate %d bytes!\n",
	    NUM_SEND_BUFFERS*sizeof(SBuffer));
    teac_Close(result);
    return(NULL);
  }
  for (i=1; i<NUM_SEND_BUFFERS; i++)
    result->sendWrappers[i]= result->sendWrappers[0] + i;

  if (!(result->rbuf_ready= (E3_uint32 *)
	elan3_allocMain(result->ctx, 0, 
			sizeof(E3_uint32)))) {
    perror("teac_Init: elan3_allocMain failed for rbuf_ready");
    teac_Close(result);
    return(NULL);
  }

  for (i=0; i<NUM_SEND_BUFFERS; i++) {
    char* buf;
    if (!(buf= (char*)elan3_allocMain(result->ctx, 8, 
				      E_BUFFER_INITIAL_SIZE))) {
      perror("teac_Init: elan3_allocMain failed for buffer block");
      teac_Close(result);
      return(NULL);
    }
    result->sendWrappers[i]->bufId= i;
    result->sendWrappers[i]->totSize= E_BUFFER_INITIAL_SIZE;
    result->sendWrappers[i]->validSize= 0;
    result->sendWrappers[i]->buf= buf;
  }
  
  elan3_initevent_word (result->ctx, 
			result->s_event, result->m_snd);
  elan3_initevent_word (result->ctx, 
			result->rbuf_pull_event, result->rbuf_ready);
  
  for (i=0; i<NUM_SEND_BUFFERS; i++) {
    elan3_initevent_word (result->ctx, 
			  result->sbuf_pull_event[i], result->sbuf_ready[i]);
  }

  for (j=0; j<cap->Entries; j++) 
    for (i=0; i<NUM_SEND_BUFFERS; i++) {
      elan3_initevent_word (result->ctx, 
			    result->r_event[j][i], &(result->m_rcv[j][i]));
    }
  
  /* Get the message receive events ready to fire, in case something
   * comes in before receive gets called.
   */
  for (j=0; j<cap->Entries; j++)
    for (i=0; i<NUM_SEND_BUFFERS; i++) {
      elan3_primeevent(result->ctx, result->r_event[j][i], 1);
    }

  /* Fire the sbuffer free events, so that the buffers look free when 
   * the first call to send happens.
   */
  for (i=0; i<NUM_SEND_BUFFERS; i++) {
    elan3_primeevent(result->ctx, result->sbuf_pull_event[i], 1);
    elan3_setevent( result->ctx, result->sbuf_pull_event[i] );
  }
  
  /* And now we're ready to face the world. */
  elan3_block_inputter (result->ctx, 0);
  
  return(result);
}
  
void teac_Close(Tcomm *tcomm)
{
  int i;
#ifdef never
  char buf[256];
#endif

  if (tcomm) {
    /* First we have to wait until all pending messages have been
     * pulled (assuming they got initialized in the first place).
     */
    if ((tcomm->sbuf_pull_event[0] != 0) && (tcomm->sbuf_ready[0] != NULL)) {
      for (i=0; i<NUM_SEND_BUFFERS; i++) {
	elan3_waitevent_word(tcomm->ctx, tcomm->sbuf_pull_event[i],
			     tcomm->sbuf_ready[i], 10);
      }
      fprintf(stderr,"All TEAC messages have reported home!\n");
    }
    elan3_block_inputter (tcomm->ctx, 1);

    if (tcomm->e_dma != 0) elan3_freeElan(tcomm->ctx, tcomm->e_dma);
    if (tcomm->s_event != 0) elan3_freeElan(tcomm->ctx, tcomm->s_event);
    if (tcomm->r_event != NULL) {
      if (tcomm->r_event[0] != NULL) {
	if (tcomm->r_event[0][0] != 0) elan3_freeElan(tcomm->ctx, 
						      tcomm->r_event[0][0]);
	crFree(tcomm->r_event[0]);
      }
      crFree(tcomm->r_event);
    }
    if (tcomm->sbuf_pull_event[0] != 0) 
      elan3_freeElan(tcomm->ctx, tcomm->sbuf_pull_event[0]);
    if (tcomm->sendWrappers[0] != NULL) {
      for (i=0; i<NUM_SEND_BUFFERS; i++) {
	if (tcomm->sendWrappers[i]->buf != NULL) 
	  elan3_free(tcomm->ctx, tcomm->sendWrappers[i]->buf);
      }
      crFree(tcomm->sendWrappers[0]);
    }
    if (tcomm->rbuf_pull_event != 0) 
      elan3_freeElan(tcomm->ctx, tcomm->rbuf_pull_event);
    if (tcomm->m_snd != NULL) elan3_free(tcomm->ctx, 
					 (E3_uint32*)tcomm->m_snd);
    if (tcomm->m_rcv != NULL) {
      if (tcomm->m_rcv[0] != NULL) elan3_free(tcomm->ctx,
					      (E3_uint32*)tcomm->m_rcv[0]);
      crFree(tcomm->m_rcv);
    }
    if (tcomm->sbuf_ready[0] != NULL) 
      elan3_free(tcomm->ctx, (E3_uint32*)tcomm->sbuf_ready[0]);
    if (tcomm->rbuf_ready != NULL) elan3_free(tcomm->ctx, 
					    (E3_uint32*)tcomm->rbuf_ready);
    if (tcomm->mbuff != NULL) {
      if (tcomm->mbuff[0] != NULL) elan3_free(tcomm->ctx, tcomm->mbuff[0]);
      crFree(tcomm->mbuff);
    }
#ifdef never
    elan3_detach(tcomm->ctx);
    fprintf(stderr,"tcomm string: <%s>\n",teac_getTcommString(tcomm,buf,256));
    elan3_fini(tcomm->ctx);
#endif
  }
}

int teac_Select(Tcomm* tcomm, int *ids, int num_ids, int timeout)
{
  int id;
  while (timeout-- > 0) {
    if ((id= teac_Poll(tcomm, ids, num_ids)) >= 0) return id;
  }

  return -1;
}

int teac_Poll(Tcomm* tcomm, int *ids, int num_ids)
{
  int i;
  int j;

  for (j=0; j<num_ids; j++) {
    int index= (j+tcomm->poll_shift) % num_ids;
    int thisId= ids[index];
    for (i=0; i<NUM_SEND_BUFFERS; i++) {
      if (elan3_pollevent_word(tcomm->ctx, &(tcomm->m_rcv[thisId][i]), 1)) {
	tcomm->poll_shift= index;
	return thisId;
      }
    }
  }
  
  return -1;
}

int teac_sendBufferAvailable(Tcomm* tcomm)
{
  int i;
  for (i=0; i<NUM_SEND_BUFFERS; i++) {
    if (elan3_pollevent_word(tcomm->ctx, tcomm->sbuf_ready[i], 1))
      return 1;
  }
  return 0;
}

SBuffer* teac_getSendBuffer( Tcomm* tcomm, long size )
{
  /* Find a free send buffer.  We'll busy wait in this poll loop
   * if necessary.
   */
  int i= 0;
  while (1) {
    if (elan3_pollevent_word(tcomm->ctx, tcomm->sbuf_ready[i],
			     1)) break;
    if (++i == NUM_SEND_BUFFERS) i= 0;
  }
  /* We will use this buffer! */
#ifdef never
  fprintf(stderr,"Allocated message buffer %d\n",i);
#endif
  *(tcomm->sbuf_ready[i])= 0; /* mark it busy */

  /* If the associated chunk of memory is smaller than that requested,
   * replace it with something larger.
   */
  if (tcomm->sendWrappers[i]->totSize < size) {
    elan3_free( tcomm->ctx, tcomm->sendWrappers[i]->buf );
    if (!(tcomm->sendWrappers[i]->buf= 
	  (char*)elan3_allocMain(tcomm->ctx, 8, size))) {
      perror("teac_getSendBuffer: failed to grow send buffer");
      exit(-1);
    }
  }
  tcomm->sendWrappers[i]->totSize= size;
  tcomm->sendWrappers[i]->validSize= 0;
  return tcomm->sendWrappers[i];
}

int teac_Send( Tcomm* tcomm, int* ids, int num_ids, SBuffer* buf, void *start )
{
  int	vp = tcomm->vp;
  int	iBuf;
  int   iDest;
  teacMsg *msg;

  /* Reality check: is this one of my buffers? */
  if (buf->bufId<0 || buf->bufId>=NUM_SEND_BUFFERS) {
    fprintf(stderr,"teac_Send: I don't know this buffer!\n");
    return 0;
  }

  /* Reality check: did they write too much into the message? */
  if (buf->validSize > buf->totSize) {
    fprintf(stderr,"teac_Send: message too large! (%ld vs %ld)\n",
	    buf->validSize, buf->totSize);
    abort();
    return 0;
  }

  iBuf= buf->bufId;
  msg = &(tcomm->mbuff[vp][iBuf]);
  msg->msgnum = tcomm->msgnum++;
  msg->size = buf->validSize;
  msg->host = vp;
  if ( start != NULL )
	  msg->mptr = teac_main2elan( tcomm->ctx, start );
  else
  	msg->mptr = teac_main2elan(tcomm->ctx, buf->buf);
  msg->clr_event = elan3_sdram2elan(tcomm->ctx, tcomm->ctx->sdram,
				    tcomm->sbuf_pull_event[iBuf]);
  msg->new= 1;
  
  /* Set up the parts of the DMA that are not specific to destination */
  tcomm->dma->dma_type = E3_DMA_TYPE(DMA_BYTE,DMA_WRITE,DMA_NORMAL,0);
  tcomm->dma->dma_size = sizeof(teacMsg);
  tcomm->dma->dma_srcEvent = 
    elan3_sdram2elan(tcomm->ctx,tcomm->ctx->sdram,tcomm->s_event);
  tcomm->dma->dma_source = teac_main2elan(tcomm->ctx, msg);
  elan3_primeevent(tcomm->ctx, tcomm->sbuf_pull_event[buf->bufId], num_ids);

  /* Send this message off to each destination */
  for (iDest=0; iDest<num_ids; iDest++) {
    tcomm->dma->dma_srcCookieVProc = 
      elan3_local_cookie(tcomm->ctx, vp, ids[iDest]);
    tcomm->dma->dma_destCookieVProc = ids[iDest];
    tcomm->dma->dma_destEvent = 
      elan3_sdram2elan(tcomm->ctx,tcomm->ctx->sdram,
		       tcomm->r_event[vp][iBuf])
      + sdramAddrBase[(ids[iDest]/NUM_SEND_BUFFERS) + tcomm->lhost] 
      - sdramAddrBase[(vp/NUM_SEND_BUFFERS) + tcomm->lhost];
    tcomm->dma->dma_dest = teac_main2elan(tcomm->ctx, msg)
      + elanAddrBase[(ids[iDest]/NUM_SEND_BUFFERS) + tcomm->lhost] 
      - elanAddrBase[(vp/NUM_SEND_BUFFERS) + tcomm->lhost];
    elan3_primeevent(tcomm->ctx, tcomm->s_event, 1);
    *(tcomm->m_snd)= 0;
    elan3_putdma_main(tcomm->ctx, tcomm->dma, tcomm->e_dma);
#ifdef never
    fprintf(stderr,"DMA dest event %x, dest mem %lx\n",
	    tcomm->dma->dma_destEvent, 
	    (long)tcomm->dma->dma_dest);
    fprintf(stderr,"Mem shifts are %x %x based on %d %d\n",
	    elanAddrBase[(ids[iDest]/NUM_SEND_BUFFERS) + tcomm->lhost],
	    elanAddrBase[(vp/NUM_SEND_BUFFERS) + tcomm->lhost],
	    ids[iDest],vp);
    fprintf(stderr,"Send msg %d in buffer %d to %d (list index %d)...",
	    msg->msgnum,iBuf, ids[iDest],iDest);
#endif
    elan3_waitevent_word(tcomm->ctx,
			 tcomm->s_event, tcomm->m_snd, ELAN_WAIT_EVENT);
#ifdef never
    fprintf(stderr,"message away!\n");
#endif
  }
  return 1;
}

RBuffer* teac_Recv(Tcomm* tcomm, int id)
{
  int	vp = tcomm->vp;
  RBuffer* result= NULL;
  int iEvent= 0;
  int iBuf= 0;
  int i;
  int lowestMsgnum;
  
  /* poll until we get an incoming message from the given sender */
  while (1) {
    if (elan3_pollevent_word(tcomm->ctx, &(tcomm->m_rcv[id][iEvent]), 1)) 
      break;
    if (++iEvent == NUM_SEND_BUFFERS) iEvent= 0;
  }

  /* This may not be the earliest event, however. */
  lowestMsgnum= -1;
  for (i=0; i<NUM_SEND_BUFFERS; i++) {
#ifdef never
    fprintf(stderr,"Testing for new msg at %lx -> %lx\n",
	    (long)&(tcomm->mbuff[id][i]), 
	    (long)teac_main2elan(tcomm->ctx,(void*)(&tcomm->mbuff[id][i])));
#endif
    if (tcomm->mbuff[id][i].new) {
      if ((lowestMsgnum < 0) 
	  || (tcomm->mbuff[id][i].msgnum < lowestMsgnum)) {
	lowestMsgnum= tcomm->mbuff[id][i].msgnum;
	iBuf= i;
      }
    }
  }
  if (lowestMsgnum<0) {
    fprintf(stderr,
	    "teac_Recv: internal error: can't find message I just got!\n");
    return NULL;
  }
  tcomm->mbuff[id][iBuf].new= 0; 
  tcomm->m_rcv[id][iBuf]= 0;
  elan3_primeevent(tcomm->ctx, tcomm->r_event[id][iBuf],1);
#ifdef never
  fprintf(stderr,"got msg %d in buffer %d from %d!\n",
	  tcomm->mbuff[id][iBuf].msgnum, iBuf, id);
#endif

  /* Make some space to put the message when it arrives */
  if (!(result= (RBuffer*)crAlloc(sizeof(RBuffer)))) {
    fprintf(stderr,"teac_Recv: unable to allocate %d bytes!\n",
	    sizeof(RBuffer));
    return NULL;
  }
#ifdef never
  if (!(result->buf= (void*)elan3_allocMain(tcomm->ctx, 8,E_BUFFER_SIZE))) {
    perror("teac_Recv: elan3_allocMain failed for buffer");
    return(NULL);
  }
  result->totSize= E_BUFFER_SIZE;
#endif
  if (!(result->buf= (void*)elan3_allocMain(tcomm->ctx, 8, 
					    tcomm->mbuff[id][iBuf].size))) {
    perror("teac_Recv: elan3_allocMain failed for buffer");
    return(NULL);
  }
  result->totSize= tcomm->mbuff[id][iBuf].size;
  result->validSize= tcomm->mbuff[id][iBuf].size;
  result->from= tcomm->mbuff[id][iBuf].host;
  result->senderMsgnum= tcomm->mbuff[id][iBuf].msgnum;
		
  /* Set up the DMA to pull the message */
  tcomm->dma->dma_type = E3_DMA_TYPE(DMA_BYTE,DMA_READ,DMA_NORMAL,0);
  tcomm->dma->dma_size = tcomm->mbuff[id][iBuf].size;
  tcomm->dma->dma_source = tcomm->mbuff[id][iBuf].mptr;
  tcomm->dma->dma_dest = teac_main2elan(tcomm->ctx,result->buf);
  tcomm->dma->dma_srcCookieVProc = 
    elan3_remote_cookie(tcomm->ctx, vp, tcomm->mbuff[id][iBuf].host);
  tcomm->dma->dma_destCookieVProc = 
    elan3_local_cookie(tcomm->ctx, vp, tcomm->mbuff[id][iBuf].host);
  tcomm->dma->dma_srcEvent = tcomm->mbuff[id][iBuf].clr_event; 
  tcomm->dma->dma_destEvent = 
    elan3_sdram2elan(tcomm->ctx,tcomm->ctx->sdram,
		     tcomm->rbuf_pull_event);

  
  elan3_primeevent(tcomm->ctx, tcomm->rbuf_pull_event,1);
  *(tcomm->rbuf_ready)= 0;
  elan3_getdma_main(tcomm->ctx, tcomm->dma, tcomm->e_dma);
  elan3_waitevent_word(tcomm->ctx,
		       tcomm->rbuf_pull_event, 
		       tcomm->rbuf_ready, ELAN_WAIT_EVENT);

  return(result);
}

int teac_Dispose( Tcomm* tcomm, RBuffer* buf )
{
  elan3_free(tcomm->ctx, buf->buf);
  crFree(buf);
  return 0;
}

char* teac_getTcommString(Tcomm *c, char* buf, int buflen)
{
  snprintf(buf,buflen-1,
	   "<vp= %d, host range %d-%d, ctxnum range %d-%d, msg %d>",
	   c->vp,c->lhost,c->hhost,c->lctx,c->hctx,c->msgnum);
  buf[buflen-1]= '\0';
  return buf;
}

char* teac_getConnString(Tcomm *c, int id, char* buf, int buflen)
{
  int rel_rank= id%4;
  int node= ((id-rel_rank)/4) + c->lhost;
  snprintf(buf,buflen-1,"vp %d, <%s>:%d",id,hosts[node].name,rel_rank);
  buf[buflen-1]= '\0';
  return buf;
}

int teac_getConnId(Tcomm *c, const char* host, int rank)
{
  int node= trans_host(host);
#ifdef never
  fprintf(stderr,"getConnId: <%s> %d %d maps to %d %d\n",
	  host, rank, c->lhost, node, (4*(node - c->lhost) + (rank%4)));
#endif
  return (4*(node - c->lhost) + (rank%4));
}
