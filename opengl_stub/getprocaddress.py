# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.

import sys

sys.path.append("../glapi_parser")
import apiutil

apiutil.CopyrightC()

print """
/* DO NOT EDIT - THIS FILE GENERATED BY THE getprocaddress.py SCRIPT */
#include "chromium.h"
#include "cr_string.h"
#include "cr_version.h"
#include "stub.h"


struct name_address {
  const char *name;
  CR_PROC address;
};

static struct name_address functions[] = {
"""


keys = apiutil.GetAllFunctions("../glapi_parser/APIspec.txt")
for func_name in keys:
	if "Chromium" == apiutil.Category(func_name):
		continue
	if func_name == "BoundsInfoCR":
		continue
	if "GL_chromium" == apiutil.Category(func_name):
		pass #continue

	wrap = apiutil.GetCategoryWrapper(func_name)
	name = "gl" + func_name
	address = "gl" + func_name
	if wrap:
		print '#ifdef CR_%s' % wrap
	print '\t{ "%s", (CR_PROC) %s },' % (name, address)
	if wrap:
		print '#endif'


print "\t/* Chromium binding/glue functions */"

for func_name in keys:
	if (func_name == "Writeback" or
		func_name == "BoundsInfoCR"):
		continue
	if apiutil.Category(func_name) == "Chromium":
		print '\t{ "cr%s", (CR_PROC) cr%s },' % (func_name, func_name)

print """
\t/* GLX functions */
#ifdef CR_GLX_VERSION_1_0
\t/* GLX 1.0 */
\t{ "glXChooseVisual", (CR_PROC) glXChooseVisual },
\t{ "glXCopyContext", (CR_PROC) glXCopyContext },
\t{ "glXCreateContext", (CR_PROC) glXCreateContext },
\t{ "glXCreateGLXPixmap", (CR_PROC) glXCreateGLXPixmap },
\t{ "glXDestroyContext", (CR_PROC) glXDestroyContext },
\t{ "glXDestroyGLXPixmap", (CR_PROC) glXDestroyGLXPixmap },
\t{ "glXGetConfig", (CR_PROC) glXGetConfig },
\t{ "glXGetCurrentContext", (CR_PROC) glXGetCurrentContext },
\t{ "glXGetCurrentDrawable", (CR_PROC) glXGetCurrentDrawable },
\t{ "glXIsDirect", (CR_PROC) glXIsDirect },
\t{ "glXMakeCurrent", (CR_PROC) glXMakeCurrent },
\t{ "glXQueryExtension", (CR_PROC) glXQueryExtension },
\t{ "glXQueryVersion", (CR_PROC) glXQueryVersion },
\t{ "glXSwapBuffers", (CR_PROC) glXSwapBuffers },
\t{ "glXUseXFont", (CR_PROC) glXUseXFont },
\t{ "glXWaitGL", (CR_PROC) glXWaitGL },
\t{ "glXWaitX", (CR_PROC) glXWaitX },
#endif
#ifdef CR_GLX_VERSION_1_1
\t/* GLX 1.1 */
\t{ "glXGetClientString", (CR_PROC) glXGetClientString },
\t{ "glXQueryServerString", (CR_PROC) glXQueryServerString },
\t{ "glXQueryExtensionsString", (CR_PROC) glXQueryExtensionsString },
#endif
#ifdef CR_GLX_VERSION_1_2
\t/* GLX 1.2 */
\t{ "glXGetCurrentDisplay", (CR_PROC) glXGetCurrentDisplay },
#endif
#ifdef CR_GLX_VERSION_1_3
\t/* GLX 1.3 */
\t{ "glXChooseFBConfig", (CR_PROC) glXChooseFBConfig },
\t{ "glXCreateNewContext", (CR_PROC) glXCreateNewContext },
\t{ "glXCreatePbuffer", (CR_PROC) glXCreatePbuffer },
\t{ "glXCreatePixmap", (CR_PROC) glXCreatePixmap },
\t{ "glXCreateWindow", (CR_PROC) glXCreateWindow },
\t{ "glXDestroyPbuffer", (CR_PROC) glXDestroyPbuffer },
\t{ "glXDestroyPixmap", (CR_PROC) glXDestroyPixmap },
\t{ "glXDestroyWindow", (CR_PROC) glXDestroyWindow },
\t{ "glXGetCurrentReadDrawable", (CR_PROC) glXGetCurrentReadDrawable },
\t{ "glXGetFBConfigAttrib", (CR_PROC) glXGetFBConfigAttrib },
\t{ "glXGetFBConfigs", (CR_PROC) glXGetFBConfigs },
\t{ "glXGetSelectedEvent", (CR_PROC) glXGetSelectedEvent },
\t{ "glXGetVisualFromFBConfig", (CR_PROC) glXGetVisualFromFBConfig },
\t{ "glXMakeContextCurrent", (CR_PROC) glXMakeContextCurrent },
\t{ "glXQueryContext", (CR_PROC) glXQueryContext },
\t{ "glXQueryDrawable", (CR_PROC) glXQueryDrawable },
\t{ "glXSelectEvent", (CR_PROC) glXSelectEvent },
#endif
#ifdef CR_GLX_VERSION_1_4
\t/* GLX 1.4 */
\t/* nothing */
#endif
"""



print """
	{ NULL, NULL }
};

CR_PROC CR_APIENTRY crGetProcAddress( const char *name )
{
	int i;
	stubInit(); /*this can cause problems with threaded apps */

	for (i = 0; functions[i].name; i++) {
		if (crStrcmp(name, functions[i].name) == 0) {
			return functions[i].address;
		}
	}

	return NULL;
}

"""



# XXX should crGetProcAddress really handle WGL/GLX functions???

print_foo = """
/* As these are Windows specific (i.e. wgl), define these now.... */
#ifdef WINDOWS
	{
		wglGetExtensionsStringEXTFunc_t wglGetExtensionsStringEXT = NULL;
		wglChoosePixelFormatFunc_t wglChoosePixelFormatEXT = NULL;
		wglGetPixelFormatAttribivEXTFunc_t wglGetPixelFormatAttribivEXT = NULL;
		wglGetPixelFormatAttribfvEXTFunc_t wglGetPixelFormatAttribfvEXT = NULL;
		if (!crStrcmp( name, "wglGetExtensionsStringEXT" )) return (CR_PROC) wglGetExtensionsStringEXT;
		if (!crStrcmp( name, "wglChoosePixelFormatEXT" )) return (CR_PROC) wglChoosePixelFormatEXT;
		if (!crStrcmp( name, "wglGetPixelFormatAttribivEXT" )) return (CR_PROC) wglGetPixelFormatAttribivEXT;
		if (!crStrcmp( name, "wglGetPixelFormatAttribfvEXT" )) return (CR_PROC) wglGetPixelFormatAttribfvEXT;
	}
#endif
"""
