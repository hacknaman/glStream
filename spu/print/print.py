# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.


import sys,os;
import cPickle;
import string;
import re;

sys.path.append( "../../opengl_stub" )
parsed_file = open( "../../glapi_parser/gl_header.parsed", "rb" )
gl_mapping = cPickle.load( parsed_file )

import stub_common;

stub_common.CopyrightC()

print """
/* DO NOT EDIT - THIS FILE AUTOMATICALLY GENERATED BY print.py SCRIPT */
#include <stdio.h>
#include "cr_error.h"
#include "cr_spu.h"
#include "printspu.h"

#define PRINT_UNUSED(x) ((void)x)"""

keys = gl_mapping.keys()
keys.sort();

printf_mapping = {
	'GLint':      '%d',
	'GLshort':    '%hd',
	'GLbyte':     '%d',
	'GLubyte':    '%u',
	'GLuint':     '%u',
	'GLushort':   '%hu',
	'GLenum':     '%s',
	'GLfloat':    '%f',
	'GLclampf':   '%f',
	'GLdouble':   '%f',
	'GLclampd':   '%f',
	'GLbitfield': '0x%x',
	'GLboolean':  '%s',
	'GLsizei':    '%u'
}

for func_name in keys:
	(return_type, names, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( 'printspu', func_name ): 
		print 'extern %s PRINT_APIENTRY print%s%s;' % (return_type, func_name, stub_common.ArgumentString( names, types ) )

for func_name in keys:
	if stub_common.FindSpecial( 'printspu_unimplemented', func_name ): continue
	if stub_common.FindSpecial( 'printspu', func_name ): continue
	(return_type, names, types) = gl_mapping[func_name]
	print '\n%s PRINT_APIENTRY print%s%s' % (return_type, func_name, stub_common.ArgumentString( names, types ))
	print '{'
	print '\tfprintf( print_spu.fp, "%s(' % func_name ,

	printfstr = ""
	argstr = ", "

	vector_nelem = stub_common.IsVector( func_name )
	if vector_nelem != 0:
		vector_arg_type = re.sub( r'\*', '', types[len(types)-1] )
		vector_arg_type = re.sub( r'const ', '', vector_arg_type )
		vector_arg_type = string.strip( vector_arg_type );
	for i in range(len(names)):
		name = names[i]
		type = types[i]
		if type == 'void':
			printfstr = ""
			argstr = ""
			break;

		if vector_nelem != 0 and i == len(names)-1:
			printfstr += '['
			for index in range( vector_nelem ):
				if printf_mapping.has_key( vector_arg_type ):
					printfstr += printf_mapping[vector_arg_type]
					arg = '%s[%d]' % (names[len(names)-1], index)
					if vector_arg_type == 'GLboolean':
						argstr += '%s ? "true" : "false"' % arg
					else:
						argstr += arg
				if index != vector_nelem - 1:
					printfstr += ", "
					argstr += ", "
			printfstr += ']'
		else:
			if printf_mapping.has_key( type ):
				printfstr += printf_mapping[type];
				if type == 'GLenum':
					argstr += 'printspuEnumToStr( %s )' % name
				elif type == 'GLboolean':
					argstr += '%s ? "true" : "false"' % name
				else:
					argstr += name
			elif type.find( "*" ):
				printfstr += "%p"
				argstr += name
			else:
				argstr = ""
				printfstr = "???"
				break;
			if i != len(names) - 1:
				printfstr += ", "
				argstr += ", "
				
	print '%s )\\n"%s );' % ( printfstr, argstr )
	print '\tfflush( print_spu.fp );'

	if return_type == "GLint":
		print '\t{'
		print '\t\tint res =',
	else:
		if return_type != "void":
			print '\treturn',
		else:
			print '\t',
	print 'print_spu.passthrough.%s%s;' % ( func_name, stub_common.CallString( names ) )
	if return_type == "GLint":
		print '\t\tfprintf( print_spu.fp, "= %d\\n", res);'
		print '\t\treturn res;'
		print '\t}'
	print '}'

print 'SPUNamedFunctionTable print_table[] = {'
for index in range(len(keys)):
	func_name = keys[index]
	if stub_common.FindSpecial( 'printspu_unimplemented', func_name ): continue
	print '\t{ "%s", (SPUGenericFunction) print%s },' % (func_name, func_name )
print '\t{ NULL, NULL }'
print '};'
