# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.

import sys,os;
import cPickle;
import string;
import re;

sys.path.append( "../../opengl_stub" )
parsed_file = open( "../../glapi_parser/gl_header.parsed", "rb" )
gl_mapping = cPickle.load( parsed_file )

import stub_common;

keys = gl_mapping.keys()
keys.sort();

stub_common.CopyrightC()

print """
/* DO NOT EDIT - generated by feedback.py */
#include <stdio.h>
#include "cr_spu.h"
#include "feedbackspu.h"
#include "cr_packfunctions.h"
#include "cr_glstate.h"

"""
for func_name in keys:
	(return_type, args, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( "feedback_state", func_name ):
		print 'extern %s FEEDBACKSPU_APIENTRY feedbackspu_%s%s;' % ( return_type, func_name, stub_common.ArgumentString( args, types ) )

print ""

for index in range(len(keys)):
	func_name = keys[index]
	(return_type, args, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( "feedback", func_name ):
		print '%s FEEDBACKSPU_APIENTRY feedbackspu_%s%s' % ( return_type, func_name, stub_common.ArgumentString( args, types ) )
		print '{'
		print '\tfeedback_spu.super.%s%s;' % ( func_name, stub_common.CallString( args ) )
		print '}'



print """
#define CHANGE( name, func ) crSPUChangeInterface( &(feedback_spu.self), feedback_spu.self.name, (SPUGenericFunction) func )
#define CHANGESWAP( name, swapfunc, regfunc ) crSPUChangeInterface( &(feedback_spu.self), feedback_spu.self.name, (SPUGenericFunction) (feedback_spu.swap ? swapfunc: regfunc ) )

static void __loadFeedbackAPI( void )
{
"""
for index in range(len(keys)):
	func_name = keys[index]
	(return_type, args, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( "feedback", func_name ):
		print '\tCHANGE( %s, crStateFeedback%s );' % (func_name, func_name )
print """
}

static void __loadSelectAPI( void )
{
"""
for index in range(len(keys)):
	func_name = keys[index]
	(return_type, args, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( "select", func_name ):
		print '\tCHANGE( %s, crStateSelect%s );' % (func_name, func_name )
	elif stub_common.FindSpecial( "feedback", func_name ):
		print '\tCHANGE( %s, feedbackspu_%s );' % (func_name, func_name )
print """
}

static void __loadRenderAPI( void )
{
"""

for index in range(len(keys)):
	func_name = keys[index]
	(return_type, args, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( "feedback", func_name ):
		print '\tCHANGE( %s, feedbackspu_%s );' % (func_name, func_name )
#	if stub_common.FindSpecial( "select", func_name ):
#		print '\tCHANGE( %s, feedbackspu_%s );' % (func_name, func_name )
print """
}
"""

print """
GLint FEEDBACKSPU_APIENTRY feedbackspu_RenderMode ( GLenum mode )
{
	feedback_spu.render_mode = mode;

	switch (mode) {
		case GL_FEEDBACK:
			/*printf("Switching to Feedback API\\n");*/
			__loadFeedbackAPI( );
			break;
		case GL_SELECT:
			/*printf("Switching to Selection API\\n");*/
			__loadSelectAPI( );
			break;
		case GL_RENDER:
			/*printf("Switching to Render API\\n");*/
			__loadRenderAPI( );
			break;
	}

	return crStateRenderMode( mode );
}

void FEEDBACKSPU_APIENTRY feedbackspu_Begin ( GLenum mode )
{
	crStateBegin( mode );

	if (feedback_spu.render_mode == GL_FEEDBACK)
		crStateFeedbackBegin( mode );
	else if (feedback_spu.render_mode == GL_SELECT)
		crStateSelectBegin( mode );
	else
		feedback_spu.super.Begin( mode );
}

void FEEDBACKSPU_APIENTRY feedbackspu_End ( void )
{
	crStateEnd( );

	if (feedback_spu.render_mode == GL_FEEDBACK)
		crStateFeedbackEnd( );
	else if (feedback_spu.render_mode == GL_SELECT)
		crStateSelectEnd( );
	else
		feedback_spu.super.End( );
}

void FEEDBACKSPU_APIENTRY feedbackspu_Bitmap ( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap )
{
	crStateBitmap( width, height, xorig, yorig, xmove, ymove, bitmap );

	if (feedback_spu.render_mode == GL_FEEDBACK)
		crStateFeedbackBitmap( width, height, xorig, yorig, xmove, ymove, bitmap );
	else if (feedback_spu.render_mode == GL_SELECT)
		crStateSelectBitmap( width, height, xorig, yorig, xmove, ymove, bitmap );
	else
		feedback_spu.super.Bitmap( width, height, xorig, yorig, xmove, ymove, bitmap );
}

void FEEDBACKSPU_APIENTRY feedbackspu_CopyPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type )
{
	if (feedback_spu.render_mode == GL_FEEDBACK)
		crStateFeedbackCopyPixels( x, y, width, height, type );
	else if (feedback_spu.render_mode == GL_SELECT)
		crStateSelectCopyPixels( x, y, width, height, type );
	else
		feedback_spu.super.CopyPixels( x, y, width, height, type );
}

void FEEDBACKSPU_APIENTRY feedbackspu_DrawPixels( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels )
{
	if (feedback_spu.render_mode == GL_FEEDBACK)
		crStateFeedbackDrawPixels( width, height, format, type, pixels );
	else if (feedback_spu.render_mode == GL_SELECT)
		crStateSelectDrawPixels( width, height, format, type, pixels );
	else
		feedback_spu.super.DrawPixels( width, height, format, type, pixels );
}

void FEEDBACKSPU_APIENTRY feedbackspu_GetBooleanv( GLenum pname, GLboolean *params )

{
	if (pname == GL_FEEDBACK_BUFFER_SIZE ||
	    pname == GL_FEEDBACK_BUFFER_TYPE ||
	    pname == GL_SELECTION_BUFFER_SIZE)
		crStateFeedbackGetBooleanv( pname, params );
	else
		feedback_spu.super.GetBooleanv( pname, params );
}

void FEEDBACKSPU_APIENTRY feedbackspu_GetDoublev( GLenum pname, GLdouble *params )

{
	if (pname == GL_FEEDBACK_BUFFER_SIZE ||
	    pname == GL_FEEDBACK_BUFFER_TYPE ||
	    pname == GL_SELECTION_BUFFER_SIZE)
		crStateFeedbackGetDoublev( pname, params );
	else
		feedback_spu.super.GetDoublev( pname, params );
}

void FEEDBACKSPU_APIENTRY feedbackspu_GetFloatv( GLenum pname, GLfloat *params )

{
	if (pname == GL_FEEDBACK_BUFFER_SIZE ||
	    pname == GL_FEEDBACK_BUFFER_TYPE ||
	    pname == GL_SELECTION_BUFFER_SIZE)
		crStateFeedbackGetFloatv( pname, params );
	else
		feedback_spu.super.GetFloatv( pname, params );
}

void FEEDBACKSPU_APIENTRY feedbackspu_GetIntegerv( GLenum pname, GLint *params )

{
	if (pname == GL_FEEDBACK_BUFFER_SIZE ||
	    pname == GL_FEEDBACK_BUFFER_TYPE ||
	    pname == GL_SELECTION_BUFFER_SIZE)
		crStateFeedbackGetIntegerv( pname, params );
	else
		feedback_spu.super.GetIntegerv( pname, params );
}

SPUNamedFunctionTable feedback_table[] = {
"""

for index in range(len(keys)):
	func_name = keys[index]
	(return_type, args, types) = gl_mapping[func_name]
	if stub_common.FindSpecial( "feedback_state", func_name ):
		print '\t{ "%s", (SPUGenericFunction) feedbackspu_%s }, ' % ( func_name, func_name )
print """
	{ "GetBooleanv", (SPUGenericFunction) feedbackspu_GetBooleanv },
	{ "GetDoublev", (SPUGenericFunction) feedbackspu_GetDoublev },
	{ "GetFloatv", (SPUGenericFunction) feedbackspu_GetFloatv },
	{ "GetIntegerv", (SPUGenericFunction) feedbackspu_GetIntegerv },
	{ "FeedbackBuffer", (SPUGenericFunction) crStateFeedbackBuffer },
	{ "SelectBuffer", (SPUGenericFunction) crStateSelectBuffer },
	{ "InitNames", (SPUGenericFunction) crStateInitNames },
	{ "LoadName", (SPUGenericFunction) crStateLoadName },
	{ "PushName", (SPUGenericFunction) crStatePushName },
	{ "PopName", (SPUGenericFunction) crStatePopName },
	{ "Begin", (SPUGenericFunction) feedbackspu_Begin },
	{ "End", (SPUGenericFunction) feedbackspu_End },
	{ "Bitmap", (SPUGenericFunction) feedbackspu_Bitmap },
	{ "CopyPixels", (SPUGenericFunction) feedbackspu_CopyPixels },
	{ "DrawPixels", (SPUGenericFunction) feedbackspu_DrawPixels },
	{ "RenderMode", (SPUGenericFunction) feedbackspu_RenderMode },
	{ NULL, NULL }
};
"""
