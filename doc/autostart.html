<!-- Copyright (c) 2001, Stanford University
     All rights reserved.

	 See the file LICENSE.txt for information on redistributing this software.  -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>New Page 1</title>
<base target="_self">
<link rel="stylesheet" type="text/css" href="chromium.css">
</head>

<body bgcolor="#FFFFFF">

<h1 class="PageHeading">Automatic Start-up and Configuration</h1>
<p>
Normally, running a Chromium configuration involves starting the
mothership then one or more server nodes (crserver) and application nodes
(crappfaker).
With the auto-start / auto-config feature you can simply run an OpenGL
program normally and have it run on Chromium.
</p>

<h2 class="PageSubHeading">Preparation</h2>

<p>
This example assumes that Chromium is located in /usr/local/Chromium-x.y/.
Adjust these instructions accordingly if you have Chromium installed
elsewhere.
</P>
<P>
The following steps need to be taken:
</p>

<p><b>1. (For Unix/Linux) Use libcrfaker.so instead of libGL.so</b></p>
<p>
We have to trick the OpenGL application into using the crfaker library
instead of the normal OpenGL library.
One solution is to create symbolic links from libcrfaker.so to libGL.so
and libGL.so.1 and then use LD_LIBRARY_PATH to tell the application
where to find the library.
For example:

<pre>
   cd /usr/local/Chromium-x.y/cr/lib/Linux
   ln -s libcrfaker.so libGL.so
   ln -s libcrfaker.so libGL.so.1
   setenv LD_LIBRARY_PATH /usr/local/Chromium-x.y/cr/lib/Linux
</pre>

<p><b>1. (For Microsoft Windows) Use libcrfaker.dll instead of opengl32.dll</b></p>
<p>
We have to trick the OpenGL application into using the crfaker library
instead of the normal OpenGL library.
One solution is to copy the libcrfaker.dll to opengl32.dll and then
use the PATH environment variable to tell the application where to
find the library. This will ensure that the new opengl32.dll will
be picked up before the system's version.

<pre>
   cd c:\Chromium-x.y\cr\bin\WIN_NT
   copy libcrfaker.dll opengl32.dll
   set PATH=c:\Chromium-x.y\cr\bin\WIN_NT;....
</pre>

<p><b>2. Make a configuration file</b></p>
<p>
A good way to make a configuration file is with the graphical configuration
tool.
You might make, for example, a tilesort configuration.
</p>
<p>
Make sure your configuration:
</p>
<ul>
  <li>Sets the <em>Automatically Start Servers</em> option (from
      the Mothership / Options menu).
  <li>Sets the <em>System GL Path</em> option for the render SPUs so that
      the real OpenGL library is found.
  <li>Do not set the <em>Command</em> option for the application node
      (from the Node / App Node Options menu).
</ul>

<p>
Save your configuration to a file such as
<code>/usr/local/Chromium-x.y/cr/mothership/configs/myconfig.conf</code>
</p>

<p><b>XXX -temporary</b></p>
<p>
For the time being, you may have to edit your configuration file and
specify the full path to the Chromium server's python directory:
<pre>
sys.path.append( "/usr/local/Chromium-x.y/cr/mothership/server" )
</pre>
<p>
Otherwise, the configuration script may not be able to find the mothership.py
file.
</p>


<p><b>3. Set up the .crconfigs file</b></p>
<p>
The <b>.crconfigs</b> file is expected to be in your home directory (i.e. at
<code>/home/joe/.crconfigs</code>).
If it's not found there, Chromium will look in the current directory when
you start your application.
</p>
<p>
The <b>.crconfigs</b> file maps program names to configuration names.
Each line of the file is of the format:
</p>
<pre>
<em>program</em>  <em>configuration</em>
</pre>
<p>
Here's an example:
</p>

<pre>
atlantis  /usr/local/Chromium-x.y/cr/mothership/configs/myconfig.conf
city      /usr/local/Chromium-x.y/cr/mothership/configs/tilecity.conf -r1 -c2
*         /usr/local/Chromium-x.y/cr/mothership/configs/default.conf %p
</pre>

<p>
This example specifies configuration files for the atlantis and city
programs.
</p>
<p>
In the case of the city configuration, two optional command line arguments
are given to the tilecity script to set the mural rows and columns.
</p>
<p>
The * (asterisk) entry denotes a default to use when there is
no other match.
</p>
<p>
The %p sequence will be replaced by the program name.
If %d is present, it will be replaced by the current working directory.
</p>


<p><b>4. The CR_CONFIG_PATH and CR_CONFIG environment variables</b></p>
<p>
If the <b>CR_CONFIG_PATH</B> environment variable is set, it will provide an
alternate file to look in for configuration.  The file contents are
identical to that in <code>.crconfigs</code>.  It is merely an alternate way
of specifying the location.  Here's an example:
</p>
<pre>
   setenv CR_CONFIG_PATH "/tmp/autostart.conf"
</pre>
<p>
If the <b>CR_CONFIG</B> environment variable is set, the
<code>.crconfigs</code> file is not processed and no matching for program
names is done.  Instead, the contents of the
<b>CR_CONFIG</b> variable are used instead to identify which mothership
configuration file is to be used.  The same syntax is used as for
the <em>configuration</em> section of a line in the <code>.crconfigs</code> file.
Here's an example:
</p>
<pre>
   setenv CR_CONFIG "/usr/local/Chromium-x.y/cr/mothership/configs/tilecity.conf -r1 -c2"
</pre>


<h2 class="PageSubHeading">Run it!</h2>


<p>
At this point running a program, such as city, should cause everything to
start automatically.
Here's what happens:
</p>
<ul>
<li>The application (effectively linked to libcrfaker.so instead of libGL.so)
will make a GLX call which initialized the faker library.
<li>The faker library will try to contact the mothership, and fail (since
it's not running).
<li>The faker library will look for the CR_CONFIG environment variable or
lookup the program name in the .crconfigs file.
<li>The faker will now have the name of a configuration (possibly with
command line arguments).
<li>The faker will try to spawn (fork/exec) the mothership, specifying the
configuration and command line arguments.
<li>The mothership will start and create a thread that will spawn the crserver nodes.  The servers
will load their SPUs.
<li>The faker will contact the mothership and load its SPUs.
<li>Chromium will now be running.
</ul>


<h2 class="PageSubHeading">Trouble shooting</h2>

<p>
Here are some things to check if this doesn't work:
</p>
<ul>
<li>(Unix/Linux only) Run <code>ldd programname</code> and verify that you're linked against
the faker library.  You should see something like this:
<pre>
    libGL.so => /usr/local/Chromium-x.y/cr/lib/Linux/libGL.so (0x4010b000)
</pre>
/usr/local/Chromium-x.y/cr/lib/Linux/libGL.so should be a symlink to
libcrfaker.so
<li>(Microsoft Windows only) Check that the 'python.exe' application is within the system PATH if crSpawn fails. The easiest way to check this is open a 'cmd' prompt and type 'python' and hit return. If Python doesn't start - check your setup.
<li>Examine the output of the crfaker to see if your configuration is
being found:
<pre>
    CR Debug(foo:26248): Spawning mothership with argv:
    CR Debug(foo:26248): argv[0] = 'python'
    CR Debug(foo:26248): argv[1] = '/usr/local/Chromium-x.y/cr/mothership/tools/tilecity.conf'
    CR Debug(foo:26248): argv[2] = '-r1'
    CR Debug(foo:26248): argv[3] = '-c2'
</pre>
<li>Check that your configuration file is able to find the mothership.py file;
look for sys.path.append() lines.
<li>If the render servers aren't starting, make sure the
<code>auto_start</code> option is set.
<li>Make sure there aren't any other mothership instances already running by checking the output of running <code>ps -a</code> or <code>ps -e</code>.
</ul>



</body>

</html>
