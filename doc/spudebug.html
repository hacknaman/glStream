<!-- Copyright (c) 2001, Stanford University
     All rights reserved.

	 See the file LICENSE.txt for information on redistributing this software.  -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>New Page 1</title>
<base target="_self">
<link rel="stylesheet" type="text/css" href="chromium.css">
</head>

<body bgcolor="#FFFFFF">

<h1 class="PageHeading">Debugging a SPU</h1>
<p>
Debugging a Chromium SPU can be difficult (especially on the application
side).  The normal approach of running an application with a debugger won't
work since the crappfaker is needed in order to make the application use
Chromium instead of the native OpenGL library.
Debugging the crappfaker doesn't typically work since crappfaker forks/execs
the application.
</p>

<p>This section describes some techniques you can use to debug a SPU.&nbsp;</p>


<h2 class="PageSubHeading">Windows Technique 1: Write a batch file</h2>
<p>This is by far the simplest thing you can do with Windows.
Create a batch file called <code>crdebug.bat</code>, which contains the
following commands:</p>
<table width="100%"><tr><td class="GrayCodeListing">cp %1.exe c:/work/cr/scratch<br>
      cp c:/work/cr/bin/WIN_NT/crfaker.dll c:/work/cr/scratch/opengl32.dll<br>
      "C:\VS60\Common\MSDev98\Bin\MSDEV.EXE" c:\work\cr\scratch\%1.exe</td></tr></table>
<p>Using this batch file (typically put in <code>cr/bin/WIN_NT</code>), go to
the directory containing the executable, and type:</p>
<p><code>crdebug &lt;executable_name&gt;</code></p>
<p>That's it.&nbsp; But one will have to modify the paths to match where
Chromium is installed on the system.</p>

<p>This uses a &quot;scratch&quot; directory made in <code>c:\work\cr\scratch</code>.&nbsp;
It basically copies the faker DLL to the scratch directory, along with the
executable, and runs the debugger on the executable.&nbsp; Windows will search
the directory that contains the executable first, so this technique works (it's
a lot like how the application faker works).</p>
<p>This technique has a drawback, however.&nbsp; Since SPU's are loaded
explicitly when an OpenGL context is created, you cannot set a breakpoint inside
a SPU when the program is loaded.&nbsp; You have to single-step through the
program until the context is created, and then you may set breakpoints.&nbsp;
Every time you restart the Microsoft debugger, your breakpoints will all be
temporarily disabled.&nbsp; You can re-enable them all at once by using the
&quot;<code>Edit-&gt;Breakpoints</code>&quot; menu item.&nbsp; This is tedious,
but it's the path of least resistance.</p>



<h2 class="PageSubHeading">Windows Technique 2: Use a programmatic breakpoint</h2>
<p>In Windows, you can add the statement:</p>
<table width="100%"><tr><td class="GrayCodeListing">DebugBreak();</td></tr></table>
<p>anywhere in your code, and when that statement is executed, you will be
prompted to load the debugger at that point.&nbsp; The debugger will come up
pointing at some assembly code, and by stepping forward (with the F10 key)
twice, you'll be back at the place where <code>DebugBreak</code> appears.&nbsp;
The program is still running!</p>
<p>This is often a useful technique for setting conditional breakpoints deep
within a library, since you don't have to worry about waiting for the context to
be created, etc.&nbsp; Also, this is by far the best way to enter the debugger
in your <code>SPUInit</code> function.</p>



<h2 class="PageSubHeading">Linux: Create a &quot;debug&quot; directory</h2>
<p>To debug SPU's on Linux, create a directory called <code>cr/ldebug</code>,
which is populated with symlinks to the OpenGL faker library.&nbsp; Here is a
listing of the contents of that directory:</p>
<table width="100%"><tr><td class="GrayCodeListing">chromite(cr)% ls -l ldebug<br>
      total 0<br>
      lrwxrwxrwx    1 humper   graphics       41 Jul  3 10:24 libGL.so ->
      /u/humper/work/cr/lib/Linux/libcrfaker.so*<br>
      lrwxrwxrwx    1 humper   graphics        8 Jul  3 10:25 libGL.so.1 ->
      libGL.so*<br>
      lrwxrwxrwx    1 humper   graphics        8 Jul  3 10:25 libGL.so.1.0.1251 -> libGL.so*</td></tr></table>
<p>If you have &quot;<code>.</code>&quot; (the current directory) on your <code>LD_LIBRARY_PATH</code>,
you can just change to this directory before invoking the debugger.&nbsp;
Otherwise, add this directory to the head of your <code>LD_LIBRARY_PATH</code>.
Then, run gdb on the application:

<table width="100%"><tr><td class="GrayCodeListing">
    % gdb atlantis
</td></tr></table>
<p>Set a breakpoint in main and run the program:</p>
<table width="100%"><tr><td class="GrayCodeListing">
    (gdb) break main<br>
    (gdb) run
</td></tr></table>
<p>When execution stops in main, set a breakpoint in glXMakeCurrent()
then continue:</p>
<table width="100%"><tr><td class="GrayCodeListing">
    (gdb) break glXMakeCurrent<br>
    (gdb) c
</td></tr></table>
<p>At this point the SPUs will have been loaded and you can set breakpoints
in SPU functions.</p>

<p>One disadvantage to this technique is that
you won't have control over the application's working directory.&nbsp;
If you need data files
(textures, usually), you can make symlinks to those too.</p>


<h2 class="PageSubHeading">Windows/Unix: Attach a debugger to a running process</h2>
<p>Many systems will allow you to attach a debugger to a running process without
interrupting it.&nbsp; In Windows, you can do this simply by right clicking on
the process name in the Task Manager.
With Linux start gdb with <code>gdb</code> <em>program</em> <em>processID</em>.
&nbsp; This way, if you
want to emulate the <code>DebugBreak</code> functionality without using it
explicitly, you can do something like:</p>
<table width="100%"><tr><td class="GrayCodeListing">volatile int i = 10; // so
      the compiler doesn't warn or optimize it away<br>
      while (i == 10)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // EMPTY BODY<br>
      }</td></tr></table>
<p>Once your program starts to loop forever, attach the debugger, force the
value of <code>i</code> to be something else, and you've got your homemade
breakpoint.&nbsp; This is pretty tedious, but handy sometimes when <code>DebugBreak</code>
isn't available.
</p>
<p>
On Unix, use ps to find the process ID of the application.
Then, start the debugger, specifying the program and process ID.
On Linux this can done with:</p>
<table width="100%"><tr><td class="GrayCodeListing">
gdb atlantis 12345
</td></tr></table>
<p>Where 12345 is the process ID.</p>


<h2 class="PageSubHeading">Any OS: Debug SPUs on the crserver</h2>
<p>
Debugging the crserver and SPUs hosted on the crserver is usually easier
than debugging SPUs on the application side because no library tricks are
used, nor is fork/exec used.</p>
<p>
Simply run the crserver with your debugger.  Set a breakpoint in the
<code>crSPULoadChain</code>.  After that function has finished, you should
be able to put breakpoints in any SPU function.
</p>


<h2 class="PageSubHeading">Any OS: Use the Print SPU liberally</h2>
<p>The Print SPU has made debugging of other SPU's much easier.&nbsp;
By placing
it between the client and its SPU, and also in front of the Render SPU on a
server, you can see exactly what transformations are being made to the stream
by comparing the two printouts.</p>


<h2 class="PageSubHeading">Any OS: printf</h2>
<p>
If all else fails, the tried and true method of inserting printfs() in your
code is one way to determine what's going on.
</p>

</body>

</html>
