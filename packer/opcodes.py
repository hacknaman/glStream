# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.

# This script generates include/cr_opcodes.h from the gl_header.parsed file.

import sys;
import cPickle;
import string;
import re;

sys.path.append( "../opengl_stub" )

import stub_common;

parsed_file = open( "../glapi_parser/gl_header.parsed", "rb" )
gl_mapping = cPickle.load( parsed_file )

stub_common.CopyrightC()

print ""
print "/* DO NOT EDIT - THIS FILE GENERATED BY THE opcodes.py SCRIPT */"
print ""
print "#ifndef CR_OPCODES_H"
print "#define CR_OPCODES_H"
print ""

keys = gl_mapping.keys()
keys.sort();

print "/* Functions with no return value and input-only parameters */"
print "typedef enum {"

enum_index = 0
for func_name in keys:
	if not stub_common.FindSpecial( "opcode", func_name ) and not stub_common.FindSpecial( "opcode_extend", func_name ):
		print "\t%s = %d," % ( stub_common.OpcodeName( func_name ), enum_index )
		enum_index = enum_index + 1
if enum_index > 255:
	# This would have saved Mike some grief if it had been here earlier.
	print >> sys.stderr, "You have more than 255 opcodes!  You've been adding functions to"
	print >> sys.stderr, "glapi_parser/system_header/CR_GL.H!  Each new function you add"
	print >> sys.stderr, "gets an opcode assigned to it.  Fortunately for you, we have"
	print >> sys.stderr, "an ``extend'' opcode.  Please add your functions to"
	print >> sys.stderr, "packer/opcode_extend_special so as to keep the main opcode pool"
	print >> sys.stderr, "less than 255!  THIS IS A CATASTROPHIC FAILURE, and I WILL NOT CONTINUE!"
	print >> sys.stderr, "I'm putting an error in the generated header file so you won't miss"
	print >> sys.stderr, "this even if you're doing a 'make -k.'"
	print "#error -- more than 255 opcodes!  put things in packer/opcode_extend_special please!"
	sys.exit(-1)
print "\tCR_EXTEND_OPCODE=%d" % enum_index
print "} CROpcode;\n"

num_extends = 0
for func_name in keys:
	(return_type, args, types) = gl_mapping[func_name]
	if return_type != 'void' or stub_common.FindSpecial( "packer_get", func_name ) or func_name in stub_common.AllSpecials( "opcode_extend" ):
		num_extends += 1

print "/* Functions with a return value or output parameters */"
print "typedef enum {"

enum_index = 0
for func_name in keys:
	(return_type, args, types ) = gl_mapping[func_name]
	if return_type != 'void' or stub_common.FindSpecial( "packer_get", func_name ) or func_name in stub_common.AllSpecials( "opcode_extend" ):
		if enum_index != num_extends-1:
			print "\t%s = %d," % ( stub_common.ExtendedOpcodeName( func_name ), enum_index )
		else:
			print "\t%s = %d" % ( stub_common.ExtendedOpcodeName( func_name ), enum_index )
		enum_index = enum_index + 1
print "} CRExtendOpcode;\n"
print "#endif /* CR_OPCODES_H */"
